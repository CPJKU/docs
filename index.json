[{"authors":null,"categories":null,"content":"This page gives an overview of partitura and some of its most relevant features.\nIntroduction The partitura package handles richly structured musical information as conveyed by modern staff music notation. It provides a much wider range of possibilities to deal with music than the more reductive (but very common) pianoroll-oriented approach inspired by the MIDI standard.\nSpecifically, the package allows for representing a variety of information in musical scores beyond the onset, duration and MIDI pitch numbers of notes, such as:\n pitch spellings, symbolic duration categories, and voicing information.  Moreover, it supports musical notions that are not note-related, like:\n measures, tempo indications, performance directions, repeat structures, and time/key signatures.  In addition to handling score information, the package can load MIDI recordings of performed scores, and alignments between scores and performances.\nSupported file types Musical data can be loaded from and saved to MusicXML and MIDI files. Furthermore, partitura uses MuseScore \u0026lt;https://musescore.org/\u0026gt;_ as a backend to load files in other formats, like MuseScore, MuseData, and GuitarPro. This requires a working installation of MuseScore on your computer. MEI format is currently not supported, but support is planned for a future release.\nScore-performance alignments can be read from different file types by partitura. Firstly it supports reading from the Matchfile format used by the publicly available\nVienna4x22 piano corpus research dataset. Secondly there is read support for Match and Corresp files produced by Nakamura\u0026rsquo;s \u0026quot; music alignment software\nConceptual Overview This section offers some conceptual and design considerations that may be helpful when working with the package.\nRepresenting score information The package defines a musical ontology to describe musical scores that roughly follows the elements defined by the\nMusicXML specification\nMore specifically, the elements of a musical score are represented as a collection of instances of classes like Note, Measure, Slur, and Rest. These instances are attached to an instance of class Part, which corresponds to the role of an instrument in a musical score. A part may contain one or more staffs, depending on the instrument.\nIn contrast to MusicXML documents, where musical time is largely implicit, time plays a crucial role in the representation of scores in partitura. Musical elements are associated to a Part instance by specifying their start (and possibly end) times. The Part instance thus acts as a timeline consisting of a number of discrete timepoints, each of which holds references to the musical elements starting and ending at that time. The musical elements themselves contain references to their respective starting and ending timepoints. Other than that, cross-references between musical elements are used sparingly, to keep the API simple.\nMusical elements in a Part can be filtered by class and iterated over, either from a particular timepoint onward or backward, or within a specified range. For example to find the measure to which a note belongs, you would iterate backwards over elements of class Measure that start at or before the start time of the note and select the first element of that iteration.\nScore vs. performance Although the MIDI format can be used to represent both score-related (key/time signatures, tempo) and performance-related information (expressive timing, dynamics), partitura regards a MIDI file as a representation of either a a score or a performance. Therefore is has separate functions to load and save scores (:func:~partitura.load_score_midi, :func:~partitura.save_score_midi) and performances (:func:~partitura.load_performance_midi, :func:~partitura.save_performance_midi). :func:~partitura.load_score_midi offers simple quantization for unquantized MIDIs but in general you should not expect a MIDI representation of a performance to be loaded correctly as a Part instance.\nRelation to other symbolic music packages The music21 package has been around since 2008, and is one of the few python packages available for working with symbolic musical data. It is both more mature and more elaborate than partitura. The aims of partitura are different from and more modest than those of music21, which aims to provide a toolkit for computer-aided musicology. Instead, partitura intends to provide a convenient way to work with symbolic musical data in the context of problems such as musical expression modeling, or music generation. Although it is not the main aim of the package to provide music analysis tools, the package does offer functionality for pitch spelling, voice assignment and key estimation.courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"2a96191fcd7269b29c5a0c061a51eca7","permalink":"http://sildater.github.io/docs/partitura/introduction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/partitura/introduction/","section":"partitura","summary":"An overview of the partitura library","tags":null,"title":"","type":"book"},{"authors":null,"categories":null,"content":"A match file consists of three main parts. The first part at the beginning of the file contains meta-information such as versioning, names and tags, and score related information, i.e., key signature, time signature, etc. The second part is the main core of the document and contains note-wise alignments, as well as deletions and insertions entries. The third and last part is found at the end of the document and contains all listed sustain pedal events with their MIDI cc values.\nGlobal Information Lines    Syntax Value type Mandatory Description     info(matchFileVersion,value). string  Matchfile version (current 1.0.0 previous 5.0, see version changes)   info(piece,value). string  Piece name or opus number   info(scoreFileName,value). string  Corresponding score file name (e.g. musicxml)   info(scoreFilePath,value). string  Corresponding score file path   info(midiFileName,value). string  Corresponding MIDIfile name   info(midiFilePath,value). string  Corresponding MIDI file path   info(audioFileName,value). string  Corresponding audio file name   info(audioFilePath,value). string  Corresponding audio file path   info(audioFirstNote,value). float  Time of first note onset in audio file   info(audioLastNote,value). float  Time of last note onset in audio file   info(performer,value). string  Performer name   info(composer,value). string  Composer name   info(midiClockUnits,value). integer  MIDI Clock Units (MIDI parts per quarter)   info(midiClockRate,value). integer  MIDI Clock Rate (Microseconds per quarter)   info(keySignature,value). [string]  deprecated (first) Key signature (see score properties)   info(timeSignature,value). [integer / integer]  deprecated (first) Time signature (see score properties)   info(beatSubdivision,value). [int]  deprecated Beat subdivision (see score properties)   info(tempoIndication,value). [string]  deprecated Tempo directions (see score properties)   info(approximateTempo,value). float  Approximate tempo   info(subtitle,value). string  Subtitles    Score Property Lines Time Signature: scoreprop(timeSignature,TimeSigValue,Measure:Beat,Offset,Duration,OnsetInBeats).\nKey Signature: scoreprop(keySignature,KeySigValue,Measure:Beat,Offset,Duration,OnsetInBeats).\nBeat Subdivision: scoreprop(beatSubDivision,BeatSubValue,Measure:Beat,Offset,Duration,OnsetInBeats).\nDirections: scoreprop(directions,DirectionsValue,Measure:Beat,Offset,Duration,OnsetInBeats).\n   Value name Value type Description     Measure integer measure number (starting at 1, 0 for anacrusis) of the score position   Beat integer integer beat number (starting at 1) of the score position   Offset Integer / integer offset of the score position****from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float score position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   TimeSigValue integer / integer Time signature   KeySigValue  Key signature   BeatSubValue Integer ?   DirectionsValue [string] A list of performance directions    Section Lines Section in the score with reference positions in the underlying (non-unfolded) score: section(StartInBeatsUnfolded,EndInBeatsUnfolded, StartInBeatsOriginal, EndInBeatsOriginal, RepeatEndType).\nPossible values:\n   Value name Value type Description     StartInBeatsUnfolded float Start of the segment in beats in unfolded score time   EndInBeatsUnfolded float End of the segment in beats in the unfolded score time   StartInBeatsOriginal float Start of the segment in beats in the original score   EndInBeatsOriginal float End of the segment in beats in the original score   RepeatEndType [string] optional: list of type of the end of segment, e.g. “fine” “repeat left”, “volta end”, etc.    Match Lines Beat, downbeat, or any score position annotation between performance and score: stime(Measure:Beat,Offset,OnsetInBeats,AnnotationType)-ptime(Onsets).\n   Value name Value type Description     Measure integer measure number (starting at 1, 0 for anacrusis) of the score position   Beat integer integer beat number (starting at 1) of the score position   Offset Integer / integer offset of the score position****from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float score position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   AnnotationType [string] Optional: list of types of annotation, e.g. “beat”, “measure”, or “downbeat”   Onsets [integer] Array of at least one time in parts/ticks of the performance annotation corresponding to the score position    Notes in the performance:\nnote(ID,MIDIpitch,Onset,Offset,Velocity).\n   Value name Value type Description     ID integer Note identifier   MIDIpitch integer Pitch 0-127   Onset integer Time in parts/ticks of the note on message   Offset integer Time in parts/ticks of the note off message   adjustedOffset integer deprecated Sounding note off when adjusted by sustain pedal information (see pedal lines)   Velocity integer Note on velocity 0-127    Notes in the score snote(Anchor,[NoteName,Modifier],Octave,Measure:Beat,Offset,Duration,OnsetInBeats,OffsetInBeats,ScoreAttributesList).\n   Value name Value type Description     Anchor string Note identifier (we should specifically reserve “-” at the end of the anchor as “repetition”)   NoteName string Pitch class name in [C, D, E, F, G, A, B]   Modifier string pitch modifier in [“”, n, b, #, bb, x]   Octave integer octave number (scientific notation, middle C is in octave 4)   Measure integer measure number (starting at 1, 0 for anacrusis)   Beat integer integer beat number of note onset (starting at 1)   Offset integer / integer offset from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float onset position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   DurationInBeats float duration in beats   ScoreAttributesList [string] note attributes (“grace”, “appoggiatura”, etc.)    score note matched to a performed note: snote( _ , … , _ )-note( _ , … , _ ).\nsnote(Anchor,NoteName,Modifier],Octave,Measure:Beat,Offset,Duration,OnsetInBeats,OffsetInBeats,ScoreAttributesList)-note(ID,MIDIpitch,Onset,Offset,Velocity).\n   Value name Value type Description     Anchor string Note identifier (we should specifically reserve “-” at the end of the anchor as “repetition”)   NoteName string Pitch class name in [C, D, E, F, G, A, B]   Modifier string pitch modifier in [“”, n, b, #, bb, x]   Octave integer octave number (scientific notation, middle C is in octave 4)   Measure integer measure number (starting at 1, 0 for anacrusis)   Beat integer integer beat number of note onset (starting at 1)   Offset integer / integer offset from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float onset position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   DurationInBeats float duration in beats   ScoreAttributesList [string] note attributes (“grace”, “appoggiatura”, etc.)   ID integer Note identifier   MIDIpitch integer Pitch 0-127   Onset integer Time in parts/ticks of the note on message   Offset integer Time in parts/ticks of the note off message   adjustedOffset integer deprecated Sounding note off when adjusted by sustain pedal information (see pedal lines)   Velocity integer Note on velocity 0-127    Omitted score note Score notes that were omitted in the performance:\nsnote( _ , … , _ )-deletion.\nInserted Performed note: Performed notes that are not found in the score:\ninsertion-note( _ , … , _ ).\nPedal Lines Pedal lines represent MIDI cc 64 (sustain pedal) messages in the performance MIDI file.\nPedal line:\nsustain(Time,Value).\n   Value name Value type Description     Time integer Time in parts/ticks of the pedal message   Value integer Sustain pedal value 0-127    ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"0cb1a9fab15bff21672303dc694dc34e","permalink":"http://sildater.github.io/docs/match/specification/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/match/specification/","section":"match","summary":"specification of the match file format.","tags":null,"title":"Format Specification","type":"book"},{"authors":null,"categories":null,"content":"TODO: tutorial for match! (put both in the match and partitura docs) Introduction The partitura package offers a simple interface for parsing match files.\nScore-performance alignments can be read from different file types by partitura. Firstly it supports reading from the Matchfile format used by the publicly available\nVienna4x22 piano corpus research dataset.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"0b723d04d88165ec32b249ffc163e146","permalink":"http://sildater.github.io/docs/match/usage/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/match/usage/","section":"match","summary":"Learn how to use the match file format.","tags":null,"title":"Get Started with Match \u0026 Partitura","type":"book"},{"authors":null,"categories":null,"content":"   Welcome to partitura Quick code links:\nFind the technical documentation on readthedocs. Download the package from github or from pypi: pip install partitura. There is a tutorial on github with a getting started jupyter notebook.  In the navigation on the left you find the following articles:\n An overview of the Partitura Library An introduction to Repetition Handling of the Partitura Library An introduction to Match File Handling with the Partitura Library  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"239ba76436829b68588ff9672e313616","permalink":"http://sildater.github.io/docs/partitura/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/partitura/","section":"partitura","summary":"Introduction to partitura","tags":null,"title":"","type":"book"},{"authors":null,"categories":null,"content":"TODO: this page is just a proposal for rep handling in partitura and a PR, update and move! Repetition Handling Some background Currently the repeat object is a simple TimedObject with start and end time.\nRepeat objects are read from xml barline objects with repeat and Volta brackets are read from barline objects with \u0026ldquo;ending\u0026rdquo; property in partitura.score.Ending obejects and have a number property.\nThis allows for the creation of ScoreVariants based on Repeats for the unfolding of parts.\nThere are several limit cases to unfolding/segmentation:\n the endpoint of Ending objects (encoding a Volta bracket) is not automatically inferred Volta brackets with \u0026gt;2 endings are not supported Nested repeats are not supported all other navigation marks (segno, coda, capo, fine, \u0026hellip;?) are not supported  The ScoreVariant itself allows for segment-type/jump-type-agnostic ScoreVariants. As far as I understand the ScoreVariant contains a segment list of the structure:\nsv.segments = [(0,6,0),(0,6,6)(6,10,12)]  where the three numbers mean (start of segment, end of segment, cumulative/unfolded start of segment)\nsee this example by Francesco:\nwhere the possible omissions of repeats lead to these four segment lists:\n[(0, 4, 0), (4, 6, 4), (6, 12, 6), (14, 22, 12)] [(0, 4, 0), (4, 6, 4), (6, 14, 6), (6, 12, 14), (14, 22, 20)] [(0, 4, 0), (0, 4, 4), (4, 6, 8), (6, 12, 10), (14, 22, 16)] [(0, 4, 0), (0, 4, 4), (4, 6, 8), (6, 14, 10), (6, 12, 18), (14, 22, 24)]  These segments and the corresponding ScoreVariants are created from the Repeat objects. As you can see the da capo and fine are ignored. but segments can also be added to a ScoreVariant, they are just defined by positions.\nmy proposal for a Segment object I think these problems of unfolding could be solved with a partitura.score.Segment object:\nclass Segment(TimedObject): \u0026quot;\u0026quot;\u0026quot;Class that represents any segment between two navigation markers Parameters ---------- id : int/string The ID associated with this segment jump_to : list of int/string The IDs of segments where the unfolded score could jump to at the end of this segment Attributes ---------- id : int/string See parameters jump_to : list of int/string See parameters jump_id : int the id \u0026quot;\u0026quot;\u0026quot; def __init__(self, id, jump_to): super().__init__() self.id = id self.jump_to = jump_to self.jump_id = 0  Let\u0026rsquo;s go back to the score example above. This part would contain 5 segments:\n the first 4 beats, let\u0026rsquo;s call it a the beats 4 - 6 : b 6 - 12 : c 12 - 14 : d 14 - 22 : e  and their jump_to properties would look like this:\na.jump_to = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;] b.jump_to = [\u0026quot;c\u0026quot;] c.jump_to = [\u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;, end] d.jump_to = [\u0026quot;c\u0026quot;] e.jump_to = [\u0026quot;a\u0026quot;, end] # since it would be an option to not play the da capo?  PR General Score Unfolding Overhaul This PR contains the following new things in partitura.score.py:\n  class Segment(TimedObject): a segment of a part between two time points that are relevant to the repetition structure\n add_segments(part): a function adding segments to a part based on existing TimedObjects: Repeat, Ending, DaCapo, DalSegno, Segno, AlCoda, Coda, Fine get_segments(part): returns a dict of segments indexed by segment ID pretty_segments(part): creates a pretty string describing the segments of a part    class Path: a Path object encodes a sequence of segments and utility needed to extend that sequence, if it hasn\u0026rsquo;t reached an end of the part.\n unfold_paths(*args): recursively unfold and multiply a Path into all possible Paths and store these in a list get_paths(part, *args): call unfold_paths with the starting segment Path and return the resulting paths as parametrized (for options, see below) new_part_from_path(*args): create a new part from a Path new_scorevariant_from_path(*args): create a new ScoreVariant from a Path    Updated functions from which now use the new unfolding:\n iter_unfolded_parts(*args): iterator over all unfolded parts unfolded_part_maximal(*args): returns the longest unfolded part unfolded_part_alignment(*args): returns the unfolded part that best fits the note IDs in an alignment make_score_variants(*args): creates a list of ScoreVariant objects    Why? Theses changes solve limit cases of unfolding/segmentation:\n Volta brackets with \u0026gt;2 endings are supported Nested repeats are supported Other navigation marks (segno, coda, capo, fine) are supported  Additionally, the changes make the following possible:\n get all unfoldings with some specific constraints:  all! the longest! the longest without repeats after a jump mark (dal segno, al cado, da capo) all without repeats after a jump mark (dal segno, al cado, da capo) the shortest   create any unfolding:  pick any segment(s) you like from the list of segments (print(partitura.score.pretty_segments(part)) for an overview) add them to a path p = Path([\u0026quot;C\u0026quot;,\u0026quot;K\u0026quot;,\u0026quot;\u0026amp;\u0026quot;,...], segments) create a new part from this path new_part = new_part_from_path(p, part)   get informative strings about segments and paths:  as above: print(partitura.score.pretty_segments(part)) for paths use print(path) or print(path.pretty())    How? The Segments add information about the structure and the possible jumps from every segment to the part. The Path parses this tree of possible unfoldings (with constraints, if desired). The ScoreVariant creates a variant of the score based on the list of of segment IDs stored (or possibly computed) in a Path.\nOther Bits and Fixes:  load_musicxml: correct parsing of location attribute of barline tag load_musicxml: correct parsing of navigation markers (Da Capo, Al Segno, Segno, Al Coda, Coda, Fine) score.py: TimedObject subclasses for navigation markers ScoreVariant.create_variant_part(): Ignore the following score elements for the new part: Repeat, Ending, ToCoda, DaCapo, DalSegno, Segment, Page, System ScoreVariant.create_variant_part(): Check for previous clefs before adding new clef element modified the unfolding unittest and added a new more complex test for unfolding with jumps and three Volta brackets added part.measure_number_maphere added test for part.measure_number_map marked five functions as DEPRECATED (TODO: remove before merge)  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"605a5579e13554efc57eac8a366213c2","permalink":"http://sildater.github.io/docs/partitura/repetition/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/partitura/repetition/","section":"partitura","summary":"Learn how Partitura and the Match Format handles repetitions during the performance's score unfolding.","tags":null,"title":"Repetition Handling","type":"book"},{"authors":null,"categories":null,"content":"There are two open source datasets of match files available:\n Vienna 4x22 ASAP note alignments  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"d60e73f5f81c700d5280bf4b0c082253","permalink":"http://sildater.github.io/docs/match/data/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/match/data/","section":"match","summary":"There are two open source datasets of match files available:\n Vienna 4x22 ASAP note alignments  ","tags":null,"title":"Datasets","type":"book"},{"authors":null,"categories":null,"content":"TODO: tutorial for match! (put both in the match and partitura docs) Introduction The partitura package offers a simple interface for parsing match files.\nScore-performance alignments can be read from different file types by partitura. Firstly it supports reading from the Matchfile format used by the publicly available\nVienna4x22 piano corpus research dataset.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"1d2ceb1b87417391ba16ce8cfaff337d","permalink":"http://sildater.github.io/docs/partitura/matchparsing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/partitura/matchparsing/","section":"partitura","summary":"Learn how to use the match file format.","tags":null,"title":"Get Started with Match \u0026 Partitura","type":"book"},{"authors":null,"categories":null,"content":"Use the navigation on the left to:\n see the Match File Format Specification. get started with Match files using the partitura library. find data encoded as match files on github.   Get Started with Match \u0026amp; Partitura    See the Match Format Specification    Find Match Data   --   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"0129f426837c7ec67c512b7a32736fa4","permalink":"http://sildater.github.io/docs/match/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/match/","section":"match","summary":"Match documentation","tags":null,"title":"Welcome to the official Match Documentation!","type":"book"}]